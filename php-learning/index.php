<?php
/* 
require аналогично include, за исключением того, 
что при ошибке он также выдаст фатальную ошибку уровня 
E_COMPILE_ERROR. Другими словами, он остановит выполнение 
скрипта, тогда как include только выдал бы предупреждение 
E_WARNING, которое позволило бы скрипту продолжить выполнение.
*/
include 'vars.php';
require 'vars.php';
/* 
что если код из файла уже один раз был включен, 
он не будет включен и выполнен повторно и вернёт 
TRUE. Как видно из имени, он включит файл только один раз.
*/
include_once 'vars.php';
require_once 'vars.php';
// константа которую нельзя обьявить в ;
// функции должна быть в верхнем уровне вложенности;
const FOO = "num";
// можно обьявлять где угодно;
define("FOO2" ,"num2" );
// переменная
$a = "hello world";
$array = [];
// функция;
function foo($var)
{
    echo $var;
    
}
// &$var ссылка на переменную
function foo2(&$var)
{
    echo $var;
    return $var++;
}
/* 
Оператор goto используется для перехода в другую часть программы. 
Место, куда необходимо перейти указывается с помощью метки, за 
которой ставится двоеточие, после оператора goto указывается 
желаемая метка для перехода. Оператор не является неограниченным "goto". 
Целевая метка должна находиться в том же файле, в том же контексте. 
Имеется в виду, что вы не можете ни перейти за границы функции или метода, 
ни перейти внутрь одной из них. Вы также не можете перейти внутрь любой 
циклической структуры или оператора switch. Но вы можете выйти из них, и 
обычным применением оператора goto является использование его вместо многоуровневых break.
*/
// goto
goto a;
echo 'Foo';
 
a:
echo 'Bar';
// цикл for;
for ($i=0; $i < 9; $i++) { 
   echo FOO.  foo("hello")."$i \n" ;
}
// условия
if (true) {
    # code...
}elseif (false || true) {
    # code...
}else{
    # code...
}
/* 
Важно понять, как оператор switch выполняется, чтобы избежать ошибок. 
Оператор switch исполняет строчка за строчкой (на самом деле выражение 
за выражением). В начале никакой код не исполняется. Только в случае
нахождения оператора case, значение которого совпадает со значением
выражения в операторе switch, PHP начинает исполнять операторы. 
PHP продолжает исполнять операторы до конца блока switch либо 
до тех пор, пока не встретит оператор break.
*/
switch ($variable) {
    case 'value':
        # code...
        break;
    
    default:
        # code...
        break;
}/*
 Первый цикл перебирает массив, задаваемый с помощью iterable_expression. 
 На каждой итерации значение текущего элемента присваивается переменной $value.

Второй цикл дополнительно присвоит ключ текущего элемента переменной $key на каждой итерации. 

Внимание
Ссылка $value на последний элемент массива останется после окончания цикла foreach. 
Рекомендуется уничтожать ее с помощью unset(). В противном случае вы можете столкнуться с таким поведением:
*/
foreach ($array as $value)
    // code ...
foreach ($array as $key => $value)
    // code ...

?>
